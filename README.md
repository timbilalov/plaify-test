# Plaify тестовое задание #

## Сборка проекта ##

1. `gulp` - соберутся первые `dev` файлы (неминифицированные стили, спрайты и т. п.), запустится watcher, который будет отслеживать изменения в проекте. Запустится [BrowserSync](https://www.browsersync.io/), который будет автоматически перезагружать страницу при изменении файлов проекта.
1. `gulp build` - склейка и минификация стилей и скриптов, склейка спрайтов.
1. `gulp build:full` - то же самое, но плюс минификация изображений ("дорогостоящая" операция, плюс иногда бывает необходимо проконтролировать качество минифицированных изображений)


## Разделение на dev/prod ##
В проекте присутствует разделение на два вида подключения стилей и скриптов. Пару слов о каждом.

### dev ###
Основной для процесса вёрстки режим. После клонирования себе репозитория, при первоначальной настройке, если всё сделано правильно, данный режим будет включен по умолчанию. Также его можно активировать в любой момент для любой страницы, добавив переменную `?debug=1` к адресу страницы, либо для всего сайта, добавив куку `debug` со значением `1`.

В режиме dev к адресу страницы добавляется строка `[debug]`.

В данном режиме подлючается неминимизированный файл стилей `project.dev.css` вместе с sourcemaps (указание на исходные файлы .styl).
В данном режиме все файлы скриптов подлючаются по отдельности, а для каждого из них выводится в консоль отладочная информация.

В режиме разработки не затрагиваются "боевые" файлы стилей и скриптов, поэтому в нём можно вести разработку на боевом сервере, даже в тот момент, когда сайт запущен и есть вероятность "сломать сайт".

### prod ###
Данный режим автоматически устанавливается, как только проект перенесён на боевой сервер (благодаря комбинации условий с переменной `$projectName`). Но также в него можно войти в любой момент из режима dev, добавив переменную `?debug=0` к адресу страницы.

В данном режиме подключается минимизированная версия стилей `project.min.css` и один минимизированный файл со всеми скриптами `project.min.js`. Всё это идёт уже без отладочной информации. Однако, для правильной и комфортной работы логгера sentry.io, для скриптов создаётся файл sourcemaps, благодаря чему js-ошибки удобно локализировать.



## Скрипты ##
Для подключения и сборки скриптов используется система, которую с некоторыми оговорками можно назвать модульной. Для начала струкрута папки `/assets/scripts/`:
```
scripts
|-- modules
|   |-- pageLoad.js
|   |-- windowResize.js
|   |-- windowScroll.js
|   |-- ...
|
|-- debug-flag-enabled.js
|-- app.js
```

"Точкой входа" всех скриптов является файл **app.js**. В нём инициализируется объект `app = {}`, который содержит в себе несколько полезных функций.

Далее, для того, чтобы написать произвольный js-код на странице, достаточно создать новый файл и сохранить его в папке **modules** и обновить страницу. В режиме `dev` подключаются все .js файлы из папки `/assets/scripts/modules/` (в т. ч. из вложенных папок), в произвольном порядке. Ниже будет дано объяснение, почему порядок подключения файлов здесь не имеет значения.

Одна атомарная единица кода ("модуль") создаётся следующим способом:
```
app.createModule("moduleName", ["depModule1", "depModule2", ...], function() {
    console.log("module initialized"); // проверка, добавился ли модуль
    ...
});
```

Первый параметр - название модуля. В дальнейшем к модулю можно будет обратиться через `app.modules.moduleName`.

Второй (опционально) - массив, в котором перечислены названия других модулей, от которых зависит функционал текущего. Зависимости будут подключены до инициализации текущего модуля, и в том порядке, в котором они указаны в массиве. Вот почему нет необходимости задавать порядок на этапе подключения .js файлов. Изначально каждый модуль должен быть самодостаточен, но при этом зависимости всегда можно прописать, если это необходимо.

Третий - функция, которая будет инициализирована после загрузки страницы _(document ready)_.

Собственно, это всё сделано для того, чтобы уйти от одного файла main.js, в котором со временем образуется длинная простыня нечитабельного кода. Модули должны выполнять конкретные действия. Например, раскрывающиеся блоки - один модуль, прилипшая fixed шапка страницы - другой модуль, и т. д. На одной странице вполне нормально уживаются сразу несколько модулей.

Для заготовки уже написаны некоторые модули, которые используются практически в любом проекте. Некоторые из них:

* **windowResize** - диспетчер события изменения размеров окна браузера.
* **pageLoad** - диспетчер события полной загрузки страницы (отличается от document ready).
* **windowScroll** - диспетчер события прокрутки страницы.
* **linksWithHash** - определяет, есть ли на странице элементы `<a>`, у которых не проставлена ссылка (вместо неё - решётка). Полезно на продакте.

В режиме `prod` точка входа и все отдельные модули склеиваются в один минифицированный файл.

### Дополнительно ###
* Для js-кода желательно придерживаться camelCase именования для переменных и функций. Также файлы скриптов желательно сохранять под теми же именами, что и названия соответствующих модулей (например: app.modules.pageLoad и pageLoad.js).
* В сборщике проектов предусмотрено удаление кода, который следует за константой DEBUG. В режиме `dev`, с помощью этой константы удобно писать отладочный код. Например, строка `DEBUG && console.log('бла-бла-бла.. длинное описание того, что там в коде происходит')` будет **целиком** удалена из минифицированного файла. И это справедливо не только для вывода в консоль, но и для любого кода, написанного после DEBUG. Например, если писать юнит-тесты, то их можно писать там же, в коде для каждого модуля, предварительно включив их в блок `if (DEBUG) {...}`. Данная константа позволяет на выходе получить ощутимую разницу в размере файла, сохранив при этом _всю_ отладочную информацию в исходных файлах.


## Автоматическая проверка кода ##
В проекте используются линтеры: [stylint](https://www.npmjs.com/package/stylint) для файлов .styl, и [eslint](http://eslint.org/) для файлов .js. Правил довольно много, но зато на выходе мы получаем код, который у разных разработчиков имеет хотя бы общий вид. Без линтеров будет полный хаос.


## Стиль кода, принятый для данной заготовки ##

### Общее ###

* Кодировка по-умолчанию для всех файлов: utf-8 (без BOM, почему - ответ [здесь](https://toster.ru/q/303886)).
* Для отступов используются пробелы (а не табы).
* Величина отступа - 4 пробела.
* Формат окончания строки (line endings) - CRLF или LF, в зависимости от системы. На Win - CRLF (+ настроить git config --global core.autocrlf true). На Unix - LF (+ настроить git config --global core.autocrlf input).
* Отступы должны быть расставлены верно. Благодаря этому код должен правильно сворачиваться в редакторе.
* В коде по мере необходимости использовать комментарии вида: TODO: Нужно что-то сделать! NOTE: Мега-важная заметка. FIXME: Всё сломалось, нужно исправить!


### git ###

Используем специальные флаги для команд git:
* git pull --rebase origin master — для того, чтобы не создавались локальные merge-коммиты (подробное описание проблемы - [здесь](https://habrahabr.ru/post/161009/))
* git merge --no-ff branchname — для того, чтобы не засорять историю коммитов (подробное описание проблемы - [здесь](http://stackoverflow.com/questions/9069061/what-is-the-difference-between-git-merge-and-git-merge-no-ff))
* git merge --no-ff --no-commit branchname && git commit -m "your message" — то же самое, но с собственным коммит-собщением (иначе будет автоматическое)


### CSS ###

* Кавычки - двойные.
* Для именований CSS-классов используется [БЭМ-нотация](https://ru.bem.info/methodology/naming-convention/).


### JS ###

* Кавычки - двойные.
* Именование переменных в JS - camelCase.
* Для блоков if...else всегда используются фигурные скобки {...}. В одну строку не пишем.


### HTML ###

* Кавычки у атрибутов - двойные.
* Предпочтение PHP-комментариям (`<? // … ?>`) перед HTML комментариями (`<!-- … -->`).
* Не рекомендуется разбивать HTML-тег на несколько строк, независимо от того, сколько в нём атрибутов и насколько длинной оказывается из-за этого строка (это для того, чтобы можно было корректно работать с мультивыделением по строкам).